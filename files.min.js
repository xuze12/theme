"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.write = exports.walk = exports.tmp = exports.stat = exports.remove = exports.read = exports.name = exports.mkdir = exports.ls = exports.list = exports.join = exports.home = exports.exists = exports.dir = exports.cat = exports.abs = exports.swear = undefined;

var _swear = require("swear");

Object.defineProperty(exports, "swear", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_swear).default;
  }
});

var _fs = require("fs");

var _fs2 = _interopRequireDefault(_fs);

var _path2 = require("path");

var _path3 = _interopRequireDefault(_path2);

var _os = require("os");

var _util = require("util");

var _swear2 = _interopRequireDefault(_swear);

var _atocha = require("atocha");

var _atocha2 = _interopRequireDefault(_atocha);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mac = function mac() {
  return process.platform === "darwin";
};var linux = function linux() {
  return process.platform === "linux";
};var abs = (0, _swear2.default)(async function () {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ".";
  var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.cwd();
  name = await name;base = await base;if (_path3.default.isAbsolute(name)) return name;if (!base || typeof base !== "string") {
    base = process.cwd();
  }return join(base, name);
});var readFile = (0, _util.promisify)(_fs2.default.readFile);var cat = (0, _swear2.default)(async function (name) {
  name = await abs(name);return readFile(name, "utf-8").catch(function (err) {
    return "";
  });
});var dir = (0, _swear2.default)(async function (name) {
  name = await abs(name);return _path3.default.dirname(name);
});var existsAsync = (0, _util.promisify)(_fs2.default.exists);var exists = (0, _swear2.default)(async function (name) {
  name = await abs(name);return existsAsync(name).catch(function (res) {
    return res;
  });
});var home = (0, _swear2.default)(function () {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return join.apply(undefined, [(0, _os.homedir)()].concat(args)).then(mkdir);
});var join = (0, _swear2.default)(function () {
  return abs(_path3.default.join.apply(_path3.default, arguments));
});var readDir = (0, _util.promisify)(_fs2.default.readdir);var list = (0, _swear2.default)(async function (dir) {
  dir = await abs(dir);var files = await readDir(dir);return (0, _swear2.default)(files).map(function (file) {
    return abs(file, dir);
  });
});var mkdirAsync = (0, _util.promisify)(_fs2.default.mkdir);var mkdir = (0, _swear2.default)(async function (name) {
  name = await abs(name);var list = name.split(_path3.default.sep).map(function (part, i, all) {
    return all.slice(0, i + 1).join(_path3.default.sep);
  }).filter(Boolean);var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = list[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _path = _step.value;
      if (await exists(_path)) continue;await mkdirAsync(_path).catch(function (err) {});
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return name;
});var name = (0, _swear2.default)(function (file) {
  return _path3.default.basename(file);
});var removeDirAsync = (0, _util.promisify)(_fs2.default.rmdir);var removeFileAsync = (0, _util.promisify)(_fs2.default.unlink);var remove = (0, _swear2.default)(async function (name) {
  name = await abs(name);if (name === "/") throw new Error("Cannot remove the root folder `/`");if (!(await exists(name))) return name;if (await stat(name).isDirectory()) {
    await list(name).map(remove);await removeDirAsync(name).catch(function (err) {});
  } else {
    await removeFileAsync(name).catch(function (err) {});
  }return name;
});var statAsync = (0, _util.promisify)(_fs2.default.lstat);var stat = (0, _swear2.default)(async function (name) {
  name = await abs(name);return statAsync(name).catch(function (err) {});
});var tmp = (0, _swear2.default)(async function (path) {
  path = await abs(path, (0, _os.tmpdir)());return mkdir(path);
});var rWalk = function rWalk(name) {
  var file = abs(name);var deeper = async function deeper(file) {
    if (await stat(file).isDirectory()) {
      return rWalk(file);
    }return [file];
  };return list(file).map(deeper).reduce(function (all, arr) {
    return all.concat(arr);
  }, []);
};var walk = (0, _swear2.default)(async function (name) {
  name = await abs(name);if (!(await exists(name))) return [];if (linux() || mac()) {
    try {
      return await (0, _atocha2.default)("find " + name + " -type f").split("\n").filter(Boolean);
    } catch (error) {}
  }return rWalk(name).filter(Boolean);
});var writeFile = (0, _util.promisify)(_fs2.default.writeFile);var write = (0, _swear2.default)(async function (name) {
  var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  name = await abs(name);await writeFile(name, body, "utf-8");return name;
});var files = { abs: abs, cat: cat, dir: dir, exists: exists, home: home, join: join, list: list, ls: list, mkdir: mkdir, name: name, read: cat, remove: remove, stat: stat, swear: _swear2.default, tmp: tmp, walk: walk, write: write };exports.default = files;
exports.abs = abs;
exports.cat = cat;
exports.dir = dir;
exports.exists = exists;
exports.home = home;
exports.join = join;
exports.list = list;
exports.ls = list;
exports.mkdir = mkdir;
exports.name = name;
exports.read = cat;
exports.remove = remove;
exports.stat = stat;
exports.tmp = tmp;
exports.walk = walk;
exports.write = write;
